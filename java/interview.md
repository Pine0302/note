> 讲讲你理解的zookeeper
+ 它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。
+ zookeeper=文件系统+监听通知机制。
 
> MQ相关
redis5 stream
针对拼团项目：所有的拼团订单整合到另一个进程中，由生产者消费者模式，依次处理每一个订单，解决了并发的问题
 
> MQ消息丢失怎么办
+ rabbit：  
    + 生产者  
      + 1.可以选择用rabbitmq提供的事务功能，在生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，开始rabbitmq事务机制，基本上吞吐量会下来，因为太耗性能。

      + 2.（推荐）可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
    + rabbit
        + 为了防止rabbitmq自己弄丢了数据，这个你必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。 
    + 消费端
      + 这个时候得用rabbitmq提供的ack机制，简单来说，就是你关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，再程序里ack一把。

> dubbo的整体架构，底层原理，一次请求流程
 
> spring的ioc原理
+ 我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，
+ 这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。
+ 从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。
+ spring ioc指的是控制反转，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。交由Spring容器统一进行管理，从而实现松耦合


> spring事务
+ 事务的几个特性 ：原子性，一致性，隔离性，持久性
+ 1. 编程式事务管理  TransactionTemplate 侵入性事务管理   编程式事务管理是可以到代码块的
+ 2. 声明式事务管理  建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚  声明式事务管理的粒度是方法级别
 
> mybatis中$和#的区别
+ 1.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by "111", 如果传入的值是id，则解析成的sql为order by "id".
+ 2.将传入的数据直接显示生成在sql中。如：orderby将传入的数据直接显示生成在sql中。如：orderbyuser_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.
+ 3.#方式能够很大程度防止sql注入。
+ 4.$方式无法防止Sql注入。
+ 5.$方式一般用于传入数据库对象，例如传入表名.
+ 6.一般能用#的就别用$.


1、将话术模块讲述清楚

2、在呼叫服务中，文本是怎么分词的——>ik分词器+Lucene

3、有哪些技术上的挑战?——>海量数据的实时处理

4、电话机器人每天量有多大？

5、怎么支持呢？

? —>分布式架构,以及MQ的消息队列

6、ConcurrentHashMap底层原理讲解一下

7、HashMap的扩容机制 

8、线程池的初始参数及参数作用

多线程，线程池的深入使用，项目的具体情况，针对项目问一些具体的点

9、最大线程数与核心线程数的区别

分布式锁解决方案，spring主要解决了什么东西，spring与springboot区别，

消息队列怎么解决分布式事务问题，数据库查询缓慢怎么解决

1:多线程：手动创建线程池： 核心参数（核心线程数，最大线程数，线程存活时间，线程存活时间的单位，任务队列，创建线程池的工厂，还有拒绝策略）
他们的作用和原理需要看下 创建多线程的方式（Executors和手动创建）区别，Executors创建线程池的类型 和 使用场景。
如果设置的参数过大或者过小的话会有什么问题。多线程情况下怎么保证变量的可见性关键字volatile 作用 内部原理mesi 讲下，然后还有锁需要简单说
下比如锁的降级，还有锁普通方法和静态方法的区别。一个是锁定的对象一个是类。

2：因为项目中用到了dubbo和hsf。所以问下了他们的区别。

3：一些分布式事务的解决，一些场景可能系统没办法处理比如服务器宕机，然后导致事务无法回滚的问题，可以通过人工处理，消息重发或者修改数据等。

4：项目中遇到的问题，如何去查找怎么去解决。

5:说下之前用到过的中间件的原理。

6：二叉树 avl树 红黑树 B树 B+树的区别和使用场景。为什么mysql使用的是B+树 mongodb是B树 一个是关系型数据库一个是文档型数据库，查询的话mongodb要快因为它使用的是B树，这个还可以扩展下。

7：事务 传播性和事务几种和存在的问题 读未提交 读已提交 可重复读 序列化 优点和缺点以及事务的特性 （ACID原子性、一致性、隔离性、持久性，然后自己解释下。分布式事务的解决方案：如：tcc两阶段提交三阶段提交等等。说下思路。

综合：项目面试比较关注Java基础  多线程  高并发  分布式 包括候选人的沟通能力；

